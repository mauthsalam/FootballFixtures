//
//  LeagueManager.swift
//  FootballFixtures
//  Created by Longzhu on 07/07/2019.
//  Copyright Â© 2019 Longzhu. All rights reserved.
//

import Foundation

/// The object to manage league including teams and fixtures.
/// * Load league information from teams.json.
/// * Generate fixtures from season start to end date.
class LeagueManager {
    
    /// Static instance to share this object.
    private static var _inst: LeagueManager? = nil
    
    /// League information loaded from teams.json
    private var league: LeagueModel?
    /// Fixtures generated by this manager.
    private var fixtures = [(String, [FixtureModel])].init()
    /// Maximum available matches per day.
    private var MAX_MATCHES_PER_DAY = 1
    
    /**
     Create instance of manager and save to static var _inst.
    */
    init() {
        LeagueManager._inst = self
    }
    
    /**
     Return instance for this manager.
    */
    static func instance() -> LeagueManager? {
        return _inst
    }
    
    /**
     Load league from teams.json and generate fixtures according to it.
    */
    func loadAndGenerate() {
        loadTeamsFromLocalJsonFile()
        generateFixtures()
    }
    
    /**
     Return title of league.
    */
    func getLeagueTitle() -> String {
        if (league != nil) {
            return league!.league + " " + league!.season
        }
        return "No League Loaded"
    }
    
    /**
     Return number of scheduled dates between season start and end
    */
    func getAvailableDatesCount() -> Int {
        return fixtures.count
    }
    
    /**
     Return scheduled date at pos-th
    */
    func getAvaialbeDateAt(pos: Int) -> String {
        return fixtures[pos].0
    }
    
    /**
     Return all fixturs scheduled at pos-th date
    */
    func getFixturesAt(pos: Int) -> [FixtureModel] {
        return fixtures[pos].1
    }
    
    /**
     Load 'teams.json' file from project and save to self.league
    */
    private func loadTeamsFromLocalJsonFile() {
        if let path = Bundle.main.path(forResource: "teams", ofType: "json") {
            do {
                let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe)
                league = try JSONDecoder().decode(LeagueModel.self, from: data)
            } catch {
            }
        }
    }
    
    /**
     Generate fixtures by self.league
     - Precondition:
     self.league shouldn't be nil
    */
    private func generateFixtures() {
        guard let league = self.league else {
            return
        }
        guard let dates = getAvailableDays(start: league.start, end: league.end) else {
            return
        }
        var fixtures = [String: [FixtureModel]].init()
        /// Array of numbers, each is number of matches scheduled at it's position.
        var flag = [Int].init(repeating: 0, count: dates.count)
        let teamCount = league.teams.count
        var index = getNextDay(index: 0, flag: flag)
        /// Loop all available home & away teams.
        for home in 0 ... teamCount - 1  {
            for away in 0 ... teamCount - 1 {
                if home == away {
                    continue
                }
                let fixture = FixtureModel(home: league.teams[home], away: league.teams[away])
                let dt = dates[index]
                if fixtures[dt] == nil {
                    fixtures[dt] = [FixtureModel].init()
                }
                
                fixtures[dt]?.append(fixture)
                flag[index] = flag[index] + 1
                if (!checkAvailable(flag)) {
                    MAX_MATCHES_PER_DAY = MAX_MATCHES_PER_DAY + 1
                }
                index = getNextDay(index: (index + Int.random(in: 2 ... league.teams.count-1)) % flag.count, flag: flag)
                if index >= dates.count {
                    index = 0
                }
            }
        }
        self.fixtures = fixtures.sorted(by: { $0.key < $1.key })
    }
    
    /**
     Check if there is any blank or not full date.
     - Parameters:
     flag: List of numbers scheduled at it's position.
     - Returns:
     True if there is avaiable date else False
    */
    private func checkAvailable(_ flag: [Int]) -> Bool {
        for f in flag {
            if (f < MAX_MATCHES_PER_DAY) {
                return true
            }
        }
        return false
    }
    
    /**
     Get next random date to schedule.
     - Parameter index: start index to search
     - Parameter flag: array of numbers scheduled in array
     - Returns: searched index
    */
    private func getNextDay(index: Int, flag: [Int]) -> Int {
        var i = index
        while flag[i] >= MAX_MATCHES_PER_DAY {
            i = i + Int.random(in: 1 ... 3)
            if i >= flag.count {
                i = 0
            }
        }
        return i
    }
    
    /**
     Search all **Sundays** between start and end parameters.
     - Parameter start: string format of begin date to search
     - Parameter end: string format of end date to search
     - Returns: array of Date in string, all Sundays from start to end
     - Precondition:
        * start <= end, othercase return empty
        * start, end: should be in yyyy-MM-dd format, othercase return nil
    */
    private func getAvailableDays(start: String, end: String) -> [String]? {
        var dates = [String].init()
        //parse start and end date string
        let df = DateFormatter()
        df.dateFormat = "yyyy-MM-dd"
        guard let startDt = df.date(from: start) else {
            return nil
        }
        guard let endDt = df.date(from: end) else {
            return nil
        }
        //find first Sunday from startDt
        var date = startDt
        let calendar = Calendar.current
        while date <= endDt {
            if calendar.component(.weekday, from: date) == 1 {
                break
            }
            date = calendar.date(byAdding: .day, value: 1, to: date)!
        }
        //find all Sundays from first Sunday to endDt
        while date <= endDt {
            dates.append(df.string(from: date))
            date = calendar.date(byAdding: .day, value: 7, to: date)!
        }
        return dates
    }
    
}
